{"meta":{"title":"Duke","subtitle":"学海无涯","description":null,"author":"ZhangXing","url":"http://dukecheung.github.io"},"pages":[{"title":"About","date":"2018-03-28T04:52:15.591Z","updated":"2018-03-28T04:52:15.591Z","comments":true,"path":"about/index.html","permalink":"http://dukecheung.github.io/about/index.html","excerpt":"","text":"Email: dukestar@qq.com"},{"title":"Categories","date":"2018-03-27T11:41:53.033Z","updated":"2018-03-11T05:45:56.000Z","comments":true,"path":"categories/index.html","permalink":"http://dukecheung.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-03-27T13:35:28.302Z","updated":"2018-03-27T13:35:28.302Z","comments":true,"path":"tags/index.html","permalink":"http://dukecheung.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Homework 9","slug":"2019-04-30-HW9","date":"2019-04-30T12:15:30.000Z","updated":"2019-04-29T14:17:51.559Z","comments":true,"path":"2019/04/30/2019-04-30-HW9/","link":"","permalink":"http://dukecheung.github.io/2019/04/30/2019-04-30-HW9/","excerpt":"","text":"简答题","categories":[{"name":"系统分析与设计","slug":"系统分析与设计","permalink":"http://dukecheung.github.io/categories/系统分析与设计/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://dukecheung.github.io/tags/博客/"}]},{"title":"Homework 7","slug":"2019-04-29-HW7","date":"2019-04-29T14:12:30.000Z","updated":"2019-05-04T02:52:15.185Z","comments":true,"path":"2019/04/29/2019-04-29-HW7/","link":"","permalink":"http://dukecheung.github.io/2019/04/29/2019-04-29-HW7/","excerpt":"绘图题1、根据订旅馆建模文档： 绘制用例图模型（到子用例）","text":"绘图题1、根据订旅馆建模文档： 绘制用例图模型（到子用例） 给出 make reservation 用例的活动图 2、根据课程练习“投递员使用投递箱给收件人快递包裹”的业务场景 分别用多泳道图建模三个场景的业务过程 业务一 业务二 业务三 根据上述流程，给出快递柜系统最终的用例图模型 用正常色彩表示第一个业务流程反映的用例 用绿色背景表述第二个业务场景添加或修改的用例，以及支持 Actor 用黄色背景表述第三个业务场景添加或修改的用例，以及支持 Actor","categories":[{"name":"系统分析与设计","slug":"系统分析与设计","permalink":"http://dukecheung.github.io/categories/系统分析与设计/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://dukecheung.github.io/tags/博客/"}]},{"title":"Homework 6","slug":"2019-04-08-HW6","date":"2019-04-08T12:20:30.000Z","updated":"2019-04-12T05:33:24.939Z","comments":true,"path":"2019/04/08/2019-04-08-HW6/","link":"","permalink":"http://dukecheung.github.io/2019/04/08/2019-04-08-HW6/","excerpt":"一、简答题 用例的概念？","text":"一、简答题 用例的概念？ Answer ：用例是描述参与者为了某个目的使用系统的一系列相关成功和失败场景的集合。用例是文本而不是图表。 用例和场景的关系？什么是主场景或happy path？ Answer：用例是场景的集合，场景是用例的实例。Happy Path 是一种默认的场景，没有异常和错误条件，是一个”成功“场景。 用例有哪些形式？ Answer：有三种主要形式： Brief：简单的一段式描述，一般是主要的成功场景。在早期需求分析阶段，可以快速了解主题和范围。 Casual：非正式段落格式，多个段落覆盖多种场景。 Fully：详细描述所有步骤和段落，并且包含其他支持部分（如预设条件等）。在第一次需求研讨会期间，详细编写一些具有架构意义和高价值的用例。 对于复杂业务，为什么编制完整用例非常难？ Answer：因为复杂业务场景较多，较为复杂。在最初的考虑中，很难将所有的业务和需求考虑完全，并且这些业务在后续还有可能发生改变，所以编制完整用例非常困难。 什么是用例图？ Answer：用例图表示了用户和系统的交互，它是由参与者、用例、系统边界以及它们之间的关系构成的用于描述系统功能的视图。 用例图的基本符号与元素？ Answer：用例图的元素包括参与者（Actor）、用例（Use Case）、系统边界以及它们之间的关系组成。 Actor：系统的主要参与者，指与系统交互的角色。可以是人、计算机系统、组织等。用以下符号表示： Use Case：用例是描述参与者为了某个目的使用系统的一系列相关成功和失败场景的集合。使用如下符号表示： 系统边界：系统边界是用于表示正在建模的系统的边界。用如下符号表示： 关系：表示参与者与系统之间的交互或者用例之间的关联关系。使用箭头表示： 用例图的画法与步骤。 Answer： 确定研讨的系统。 使用用例图System框表示一个带研究的系统。 正确命名系统或子系统。 不要讲研究的系统名起得太泛，以免出现业务空泛的问题。 识别Actor。 识别系统的主要参与者。 识别系统依赖的外部系统。 识别用例。 识别用户级别用例。 识别子功能级别的用例。 建立参与者和用例之间的关联。 使用无方向连线，表示两者之间是双向交互的协议。 用例图给利益相关人与开发者的价值有哪些？ Answer： 帮助开发者明确系统的业务范围，服务对象以及外部依赖的系统，也可作为开发的指导，从而评估工作量，合理安排开发周期。 可以帮助利益相关人明确地看清楚系统的功能以及使用关联。 二、建模练习题选择2-3个你熟悉的类似业务的在线服务系统（或移动 APP），如定旅馆（携程、去哪儿等）、定电影票、背单词APP等，分别绘制它们用例图。并满足以下要求： 请使用用户的视角，描述用户目标或系统提供的服务 粒度达到子用例级别，并用 include 和 exclude 关联它们 请用色彩标注出你认为创新（区别于竞争对手的）用例或子用例 尽可能识别外部系统和服务 扇贝单词： 百词斩 为什么相似系统的用例图是相似的？ Answer：因为他们的参与者与用例是相似的，用户的目标也大多相同，用例与用例、用户与用例之间的关系也类似，所以用例图也是类似的。 如何利用用例图定位创新思路（业务创新、或技术创新、或商业模式创新）在系统中的作用。 Answer：用例图能够帮助我们明白用户的需求，然后可以通过对原本用例图的分析，在适当的地方进行改进，例如扇贝单词中的牛津词典功能，相比一般的APP就详细和专业了许多，可以在这个地方插入支付功能，达到一个商业模式创新的目的。 请使用 SCRUM 方法，选择一个用例图，编制某定旅馆开发的需求（backlog）开发计划表。 Answer：以携程网为例： ID Title Est Imp How to demo Note 1 注册 3 10 输入手机号，发送验证码，编辑个人信息，设置密码等。 需要发送短信 2 登陆 3 10 输入手机号和密码，也可使用短信验证码登陆。 可能需要短信 3 搜索酒店 10 30 输入酒店名或者输入目的地 GPS支持 4 排序 3 10 根据好评度或者价格等不同标准排序 5 酒店详情 5 20 点击酒店，可查看具体详情，评价等等。 6 预定 20 40 点击预定，输入入住用户信息，时间等等，然后提交订单支付。 需要支付系统支持 7 查看订单 5 20 点击订单，可查看订单信息，如酒店名称，入住时间，入住用户等等。 8 取消订单 10 20 若未入住，点击即可取消订单。 需要将费用退回支付系统 根据任务3，参考 使用用例点估算软件成本，给出项目用例点的估算。 Answer： 用例 #事务 #计算 原因 UC权重 注册 4 2 5 登陆 3 2 5 搜索酒店 2 1 地图API 10 排序 3 2 5 酒店详情 5 5 10 预定 6 3 框架 15 查看订单 2 1 10 取消订单 4 2 10","categories":[{"name":"系统分析与设计","slug":"系统分析与设计","permalink":"http://dukecheung.github.io/categories/系统分析与设计/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://dukecheung.github.io/tags/博客/"}]},{"title":"Longest Substring Without Repeating Characters","slug":"2019-04-03","date":"2019-04-03T15:21:00.000Z","updated":"2019-04-03T16:11:41.671Z","comments":true,"path":"2019/04/03/2019-04-03/","link":"","permalink":"http://dukecheung.github.io/2019/04/03/2019-04-03/","excerpt":"难度：Medium题目网址：LeetCode问题描述：","text":"难度：Medium题目网址：LeetCode问题描述： Given a string, find the length of the longest substring without repeating characters. Example 1: 1234&gt; Input: &quot;abcabcbb&quot;&gt; Output: 3 &gt; Explanation: The answer is &quot;abc&quot;, with the length of 3.&gt; 解题思路：本题其实不是很难，但是由于我好久没打代码了，结果想了一个多小时，果然是个小辣鸡。 首先，使用index记录最新不重复子串的起始下标，然后一直比较到i-1，若在这个子串中并无与s[i]重复的字符，则子串长度加一，与返回结果的长度相比较，若大于，则最终的result。若在子串中出现了与s[i]重复的字符，则下一次开始的i应与这一次的i相同，因为不能确定出现重复的字符有没有在子串中继续出现，所以直到确认目前子串中并无与s[i]相同的字符，i再进行加一。 需要注意的是，我引入了一个flag变量，用于表示子串中是否无与s[i]相同的字符，若无，则由于循环的特性，无法在循环体内进行最后的加一，挪到外部进行操作。 参考代码：123456789101112131415161718192021222324252627282930class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int result = 0, ans = 0; int index = 0; for(int i = 0;i &lt; s.length();i++)&#123; int j = index; int flag = 0; for(;j &lt; i;j++)&#123; if(s[i]==s[j])&#123; index++; i--; ans = 0; flag = 1; break; &#125;else&#123; ans++; &#125; &#125; if(flag == 0)&#123; ans++; &#125; if(ans&gt;result)&#123; result = ans; &#125; ans = 0; &#125; return result; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://dukecheung.github.io/categories/LeetCode/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://dukecheung.github.io/tags/博客/"}]},{"title":"Homework 3","slug":"2019-03-23-HW3","date":"2019-03-23T02:47:30.000Z","updated":"2019-03-23T02:52:09.683Z","comments":true,"path":"2019/03/23/2019-03-23-HW3/","link":"","permalink":"http://dukecheung.github.io/2019/03/23/2019-03-23-HW3/","excerpt":"简答题 简述瀑布模型、增量模型、螺旋模型（含原型方法）的优缺点。 从项目特点、风险特征、人力资源利用角度思考。 Answer： 瀑布模型：","text":"简答题 简述瀑布模型、增量模型、螺旋模型（含原型方法）的优缺点。 从项目特点、风险特征、人力资源利用角度思考。 Answer： 瀑布模型： 优点： 将项目分成多个阶段，每个阶段只需要关注当前阶段的情况，降低了软件开发的复杂程度。当前阶段完成后，只需要关注后续阶段。 在软件实现过程之前必须先进行创意分析和设计等工作，可以降低风险。 提供了统一的模型，使得分析、设计以及实现等过程方法有了一个统一的指导。 缺点： 依赖性强，若前面需求模糊，则后续工作无法展开。 容错性差，在后期若发现前面的阶段出现了问题，则工作量会十分巨大。 资源调配也容易出现问题，因为对知识技能的需求比较广，并且各个阶段负责的人员数量也有差异。 基于以上原因，项目容易出现延期等问题，无法按时交付。 增量模型： 优点： 增强客户对系统的信心。 降低系统失败风险。 提高系统可靠性。 提高系统的稳定性和可维护性。 缺点： 建立初始模型时，作为增量基础的基本业务服务的确定有一定难度。 增量粒度难以选择。 螺旋模型： 优点： 引入了明确的风险管理机制。 螺旋模型是风险驱动的迭代过程，有助于将软件质量作为特殊目标融入产品开发之中。 结合了瀑布模型和快速原型方法，将瀑布模型的多个阶段转化到多个迭代过程中，降低了项目的风险。 缺点： 螺旋模型强调风险分析，但说服外部客户接受和相信分析结果并作出相关反应并不容易。 风险分析需要耗费相当的成本，因此螺旋模型比较适合投资规模较大的软件项目。 失误的风险分析可能带来更大的风险。 简述统一过程三大特点，与面向对象的方法有什么关系？ Answer： 三大特点： 用例驱动（Use Case Driven） 以架构为中心（Architecture Centric） 受控的迭代式增量开发（Iterative and Evolutionary） 统一过程是一个面向对象且给予网络的程序开发方法论。 简述统一过程四个阶段的划分准则是什么？每个阶段的关键里程碑是什么？ Answer： 划分准则： 用例驱动。 以架构为中心。 受控的迭代式增量开发。 四个阶段及其里程碑： 初始阶段（Inception）：建立起目的的范围和版本，确定项目目标的可行性和稳定性，提交结果包括需求和用例。 细化阶段（Elaboration）：一次迭代结束的标志是有重大的决定或者评估出现。该阶段建立起系统需求和架构，确定实现的可行性和稳定性。 构造阶段（Construction）：开发出可以交付给用户的产品。 交付阶段（Transition）：将软件产品交付用户。 软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来了哪些好处？ Answer ：软件企业采用了统一过程进行软件开发，将开发过程划分成几个阶段，明确了不同迭代的里程碑与目标；支持CI/CD的版本交付，为固定项目周期提供了可能。这样利用软件产品范围的弹性，合理规划范围，就能使软件生产按固定节奏运行，固定迭代周期、固定开发周期、固定升级周期。这样做可以使企业按照固定节奏进行软件产品开发，方便了项目管理，并且给其提供了管理的依据，使企业更加健康地成长。","categories":[{"name":"系统分析与设计","slug":"系统分析与设计","permalink":"http://dukecheung.github.io/categories/系统分析与设计/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://dukecheung.github.io/tags/博客/"}]},{"title":"Homework 2","slug":"2019-03-15-HW2","date":"2019-03-15T02:51:22.000Z","updated":"2019-03-23T02:49:10.604Z","comments":true,"path":"2019/03/15/2019-03-15-HW2/","link":"","permalink":"http://dukecheung.github.io/2019/03/15/2019-03-15-HW2/","excerpt":"一、简答题 用简单的语言给出对分析、设计的理解。 Answer： 分析：将复杂的问题拆分，从而对问题有更深入的理解，侧重调研而不需要给出解决方案。例如分析客户需求。 设计：通过合理的规划及分析，给出在概念上满足客户的设计需求方案，侧重理论。","text":"一、简答题 用简单的语言给出对分析、设计的理解。 Answer： 分析：将复杂的问题拆分，从而对问题有更深入的理解，侧重调研而不需要给出解决方案。例如分析客户需求。 设计：通过合理的规划及分析，给出在概念上满足客户的设计需求方案，侧重理论。 用一句话描述面向对象的分析与设计的优势。 Answer：分析与设计者和实现者可以互相使用通用符号沟通，而不必是掌握编程语言的专家。 简述UML（统一建模语言）的作用。考试考哪些图？ Answer：UML是一种进行面向对象程序设计的工具，使分析和设计的结果可视化，用来把现实中的问题抽象成面向对象的解决方案，以便进一步的编码。它为交流面向对象中的设计中的需求、行为和体系结构的实现提供了一套综合的表示法。 UML有十多种视图，分四类： 用例图：用户角度：功能、执行者。 静态图：系统静态结构。 类图：概念及关系。 对象图：某种状态或时间段内，系统中活跃的对象及其关系。 包图：描述系统的分解结构。 行为图：系统的动态行为。 交互图：描述对象间的消息传递。 顺序图：强调对象间消息发送的时序。 合作图：强调对象间的动态协作关系。 状态图：对象的动态行为。状态-事件-状态迁移-响应动作。 活动图：描述系统为完成某功能而执行的操作序列。 实现图：描述系统的组成和分布情况。 构件图：组成部件及其关系。 部署图：物理体系结构及与软件单元的对应关系。 从软件本质的角度，解释软件范围（需求）控制的可能性。 Answer：软件的本质有复杂性、一致性、可变性与不可视性。基于以上特性，软件范围多数情况下对于客户和开发者都是模糊的，这形成软件产品与其他产品不同的开发过程。在多数情况下，客户与开发者能就项目的 20% 内容给出严格的需求约定，80% 的内容都是相对模糊的。所以我们需要在满足客户基本核心需求的情况下，不断发掘并满足客户感兴趣的内容，细化软件需求，扩大软件范围，从而创造出更多的价值。并且细化的软件范围，对于我们的开发也是非常有帮助的。 二、项目管理实践 看板使用练习（提交看板执行结果贴图，建议使用Git project） 使用截图工具（png格式输出），展现你团队的任务Kanban。 每个人的任务是明确的，必须一周后可以看到具体结果。 每个人的任务是1-2项。 至少包含一个团队活动任务。 UML绘图工具练习（提交贴图，必须使用UMLet） 请在参考书2或者教材中选择一个类图（给出参考书页码图号） Answer：英文教材 Applying UML and Patterns P46。","categories":[{"name":"系统分析与设计","slug":"系统分析与设计","permalink":"http://dukecheung.github.io/categories/系统分析与设计/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://dukecheung.github.io/tags/博客/"}]},{"title":"Homework 1","slug":"2019-03-11-HW1","date":"2019-03-11T12:03:00.000Z","updated":"2019-03-15T02:51:56.464Z","comments":true,"path":"2019/03/11/2019-03-11-HW1/","link":"","permalink":"http://dukecheung.github.io/2019/03/11/2019-03-11-HW1/","excerpt":"简答题 软件工程的定义。 Answer：软件工程是通过采用系统的，有纪律的，可量化的方法对软件开发，运行和维护的一种应用。","text":"简答题 软件工程的定义。 Answer：软件工程是通过采用系统的，有纪律的，可量化的方法对软件开发，运行和维护的一种应用。 解释导致 software crisis 本质原因、表现，述说克服软件危机的方法。 Answer： 定义：软件危机是指在落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致的一系列问题。 本质原因：计算机性能的迅速提升和程序的复杂性。按照老师上课的说法，需求与人月成指数关系，所以会造成问题。 表现：开发进度难以预测，开发成本难以控制，产品质量无法保证，用户对产品功能难以满足，产品难以维护。 克服方法：遵循软件工程知识体系，严格按照指南开发。 过程：明确划分步骤。 方法：指定每个步骤的内容，标准。 工具：使用合适的工具，如使得工作半自动化、自动化的工具，辅助完成软件开发。 软件生命周期。 Answer：在时间维度，对软件项目任务进行划分，又成为软件开发过程。常见有瀑布模型、螺旋模型、敏捷的模型等。 SWEBoK 的 15 个知识域（An Overview of the SWEBOK Guide 请中文翻译其名称与简短说明）。 Answer： 软件需求：表达了对软件产品的需求和约束，这些需求和约束有助于解决一些实际问题。 软件设计：是软件工程生命周期活动，在该活动中，软件需求被分析，以产生对软件内部结构及其行为的描述，这些描述将作为软件构建的基础。 软件构建：指通过详细设计、编码、单元测试、集成测试、调试和验证相结合，对工作软件进行详细创建。 软件测试：对产品质量进行评估并通过识别缺陷来改进产品质量。 软件维护：包括增强现有的功能，使软件适应新的和修改的操作环境，以及纠正缺陷。 软件配置管理：是硬件、固件、软件或它们的组合的功能和/或物理特征。 软件工程管理：包括计划、协调、测量、报告和控制一个项目或程序，以确保软件的开发和维护是系统的、有纪律的和量化的。 软件工程过程：涉及软件生命周期过程的定义、实现、评估、度量、管理和改进。 软件工程模型和方法：解决了包含多个生命周期阶段的方法。 软件质量：是一个普遍存在的软件生命周期问题。 软件工程专业实践：是指软件工程师必须具备的知识、技能和态度，以一种专业、负责和道德的方式来实践软件工程。 软件工程经济学：关注于在业务上下文中做出决策，以使技术决策与组织的业务目标保持一致。 计算基础：涵盖了为软件工程实践提供必要的计算背景的基本主题。 数学基础：涵盖了为软件工程实践提供必要数学背景的基本主题。 工程基础：涵盖了为软件工程实践提供必要的工程背景的基本主题。 简单解释 CMMI 的五个级别。例如：Level 1 - Initial：无序，自发生产模式。 Answer： Level 1 Initial 初始级：软件过程是无序的，有时甚至是混乱的，对过程无定义。工作方式处于救火的状态，不断的应对突如其来的危机 Level 2 Managed 可管理级：建立了基本的项目管理，有了项目策划和监督等机制，还有了测量和分析等可跟踪数据。 Level 3 Defined 已定义级：已将软件管理和工程两方面的过程文档化、标准化，并综合成该组织的标准软件过程。 Level 4 Quantitativel Managed 量化管理级：分析对软件过程和产品质量的详细度量数据，对软件过程和产品都有定量的控制。 Level 5 Optimizing 优化管理级：过程的量化反馈和先进的新思想、新技术促进过程持续不断改进。 用自己语言简述 SWEBok 或 CMMI（约200字）。 Answer：CMMI即能力成熟度模型集成，是由美国国防部和卡内基梅隆大学下的软件工程研究中心共同开发和研制的。其目的是帮助软件企业对软件开发过程进行管理，从而提高生产力和效率，开发出高质量的软件。它通过使用知识（能力）的不同，用不同级别表示开发企业的成熟性，不仅给出了企业能力提升的路径，也给出了企业能力评估的事实标准。","categories":[{"name":"系统分析与设计","slug":"系统分析与设计","permalink":"http://dukecheung.github.io/categories/系统分析与设计/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://dukecheung.github.io/tags/博客/"}]},{"title":"DES算法程序设计及实现","slug":"2018-11-01-DES","date":"2018-11-01T15:38:00.000Z","updated":"2018-11-02T03:11:53.961Z","comments":true,"path":"2018/11/01/2018-11-01-DES/","link":"","permalink":"http://dukecheung.github.io/2018/11/01/2018-11-01-DES/","excerpt":"算法概述DES算法共有两种功能：加密和解密。其中加密需要输入16位十六进制数的明文和密钥，解密需要输入密文和密钥。DES算法的要求输入是64位二进制数，为了方便起见，我将其改为输入16位十六进制数，转换在程序中实现。 加密过程：C=IP-1∙W∙T16∙T15∙…∙T1∙IP(M)，其中C为结果密文，M为输入明文，根据输入密钥Key进行中间的十六轮T迭代变换。 解密过程：M=IP-1∙W∙T1∙T2∙…∙T16∙IP(C)，其中M为结果明文，C为输入密文，根据输入密钥Key进行解密，需要注意的是，十六轮T迭代变换的次序与加密过程相反。","text":"算法概述DES算法共有两种功能：加密和解密。其中加密需要输入16位十六进制数的明文和密钥，解密需要输入密文和密钥。DES算法的要求输入是64位二进制数，为了方便起见，我将其改为输入16位十六进制数，转换在程序中实现。 加密过程：C=IP-1∙W∙T16∙T15∙…∙T1∙IP(M)，其中C为结果密文，M为输入明文，根据输入密钥Key进行中间的十六轮T迭代变换。 解密过程：M=IP-1∙W∙T1∙T2∙…∙T16∙IP(C)，其中M为结果明文，C为输入密文，根据输入密钥Key进行解密，需要注意的是，十六轮T迭代变换的次序与加密过程相反。以加密为例，具体步骤如下： 在算法开始，先要根据输入密钥，计算出16个子密钥。将输入密钥除去第8，16……64等奇偶校验位，进行PC-1置换，结果分为两部分，得到C0和D0两个28位数组。然后再将这两个数组进行16轮左移操作，依据LS位数表进行左移，得到结果。将每一轮的CiDi进行PC-2置换，得到第i个子密钥。 将输入明文M进行IP置换，根据IP置换表，将旧数据重新排列，然后将结果分为前后两部分L0和R0，各为32位，用作后续输入。 进入十六轮迭代。将L0和R0作为输入，进行如下变换： Li= Ri-1; Ri= Li-1&oplus;f(Ri-1,Ki)，其中f为Feistel函数，Ki为第i个子密钥，需要注意的是，若在解密过程中，Ki则应为17-i个子密钥(i=1,……,17)。 Feistel轮函数，步骤如下： 首先将输入的Ri-1根据E扩展表进行扩展，变为48位。 将第一步得到的结果与Ki做48位二进制按位异或运算。 将上一步结果分为8组，每组为6位，所以要循环8次。在每一轮循环中，分组第一位与第六位按二进制转为十进制，作为行数目；第二三四五位按二进制转为十进制数，作为列数目。然后在第i个S盒中找到对应的行列数，取出相应数字，然后将其转为四位二进制数，保存起来。 将上一步每次循环得到的结果拼接，得到一个32位的串。 将该串进行P置换，结果即为Feistel函数的最终结果。 前面我们进行了十六轮迭代，得到了L16和R16，将R16作为一个64位串的前半段，L16作为后半段，即为W置换。 将上一步得到的64位串根据IP-1置换表进行置换，得到的结果即是我们要求的密文。在本算法中，我将64位二进制密文结果转化为16位十六进制数输出。 总体结构Feistel结构： 模块分解 初始置换IP： 1234567891011121314 void IP_Permutation(bool *l, bool *r, bool *m)&#123; bool temp[64];//store the result after permutating for(int i = 0;i &lt; 64;i++)&#123; temp[i] = m[IP_Table[i]-1]; &#125; for(int i = 0;i &lt; 64;i++)&#123; if(i&lt;32)&#123; l[i] = temp[i];//store the left part &#125; else&#123; r[i-32] = temp[i];//store the right part &#125; &#125;&#125; 16轮迭代T： 12void Iteration_En(bool *l, bool *r, bool *out)//encryptvoid Iteration_De(bool *l, bool *r, bool *out)//decrypt 其中16轮循环，每次进行Feistel和异或运算，以函数方式调用：1234567891011121314151617181920212223242526void Feistel(bool *r, bool *k, bool *o)&#123;//feistel function bool out[48]; E_Permutation(r, out);//expand to 48 bits for(int i = 0;i &lt; 48;i++)&#123; out[i] ^= k[i];//XOR operation &#125; bool s[32] = &#123;0&#125;; for(int i = 0;i &lt; 8;i++)&#123; int h = (out[i*6]&lt;&lt;1)+out[i*6+5]; int l = (out[i*6+1]&lt;&lt;3)+(out[i*6+2]&lt;&lt;2)+(out[i*6+3]&lt;&lt;1)+out[i*6+4]; int data = S_Box[i][h-1][l-1];//select the S Box data s[i*8] = (data&amp;8)&gt;&gt;3;//convert decimal number to binary number s[i*8+1] = (data&amp;4)&gt;&gt;2; s[i*8+2] = (data&amp;2)&gt;&gt;1; s[i*8+3] = data&amp;1; &#125; P_Permutation(s, o);//put the result in o&#125;void XOR(bool *r, bool *l, bool *f)&#123;//XOR operation for(int i = 0;i &lt; 32;i++)&#123; r[i] = l[i]^f[i];//put the result in r &#125;&#125; 交换置换W： 此部分我放在迭代运算的最后：123456789//out = R16L16for(int i = 0;i &lt; 64;i++)&#123; if(i &lt; 32)&#123; out[i] = r[i]; &#125; else&#123; out[i] = l[i-32]; &#125;&#125; 逆置换IP： 123456789void IP_Inverse(bool *in)&#123;//IP inverse permutation bool temp[64]; for(int i = 0; i &lt; 64;i++)&#123; temp[i] = in[IPR_Table[i]-1]; &#125; for(int i = 0;i &lt; 64;i++)&#123; in[i] = temp[i];//update the data &#125;&#125; 输出64位，我将其转换为16位十六进制数进行输出： 123456789void Output(bool *s)&#123;//convert the binary number to hexadecimal number for(int i = 0;i &lt; 16;i++)&#123; int data = s[i*4]; data = data*2+s[i*4+1]; data = data*2+s[i*4+2]; data = data*2+s[i*4+3]; printf(\"%X\",data); &#125;&#125; 密钥调度： 1void setSubkey(bool *key) 首先将64位输入密钥转换为56位，然后进行PC-1置换，之后在循环中进行移位与PC-2置换操作：123456PC1_Permutation(k,c,d);//get C0 and R0for(int i = 0;i &lt; 16;i++)&#123; LS(c, LS_Table[i-1]);//C(i) = LS(i)(C(i-1)) LS(d, LS_Table[i-1]); PC2_Permutation(c, d, i);//set the subKey&#125; LS为根据输入次数，进行左移，以下展示PC-2置换函数：123456789101112131415void PC2_Permutation(bool *c, bool *d, int times)&#123; bool temp[56]; for(int i = 0;i &lt; 56;i++)&#123; if(i &lt; 28)&#123; temp[i] = c[i]; &#125; else&#123; temp[i] = d[i-28]; &#125; &#125; for(int i = 0;i &lt; 48;i++)&#123; subKey[times][i] = temp[PC2_Table[i]-1];//put the subKey in the array &#125;&#125; 数据结构算法并没有需要特别的数据结构，我主要是采用了Bool数组：12345bool M[64];//ciphertext or plaintextbool L[32];//Left part of Mbool R[32];//Right part of Mbool K[64];//Keybool subKey[16][48];//subKey 此外，还有几个Int数组用来存各种转换表，不做赘述。 运行结果Test1:明文：A38B77FD99ECF823密钥：37BACAE0D8BF0254加密后密文为：6D0959FE56DCF42E 解密：结果为A38B77FD99ECF823，符合要求。 Test2明文：2018103120181101密钥：7FA8920C8ABEDD87加密后密文为：27AC0F3220E42230 解密：结果为2018103120181101，符合要求。 代码戳传送门哟，有任何问题也欢迎与我交流。","categories":[{"name":"加密算法","slug":"加密算法","permalink":"http://dukecheung.github.io/categories/加密算法/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://dukecheung.github.io/tags/博客/"}]},{"title":"Unity 3D 血条制作","slug":"Unity-3D-血条制作","date":"2018-06-05T03:09:46.852Z","updated":"2018-06-05T08:53:13.019Z","comments":true,"path":"2018/06/05/Unity-3D-血条制作/","link":"","permalink":"http://dukecheung.github.io/2018/06/05/Unity-3D-血条制作/","excerpt":"要求： 分别使用 IMGUI 和 UGUI 实现 使用 UGUI，血条是游戏对象的一个子元素，任何时候需要面对主摄像机 分析两种实现的优缺点 给出预制的使用方法","text":"要求： 分别使用 IMGUI 和 UGUI 实现 使用 UGUI，血条是游戏对象的一个子元素，任何时候需要面对主摄像机 分析两种实现的优缺点 给出预制的使用方法 思路：​ 由于之前一直有用IMGUI，还算熟悉，想法就是使用一个类似长方形的容器，实现血条效果。至于UGUI，按照老师上课所讲的，使用Slider，通过调整，实现。 实现：IMGUI​ 新建一个Cube，作为游戏对象，或者空对象也可以，重点不在此处(不过还是太随便了些。。)。 ​ 新建脚本 IMGUI.cs ，初步想法：设置一根血条，两个按键，一个为攻击，即掉血，另一个为大治疗术，一下全加满。 1234567891011121314151617181920212223242526272829303132333435using System.Collections;using System.Collections.Generic;using UnityEngine;public class IMGUI : MonoBehaviour &#123; private Rect blood;//血条 private float value;//代表当前血量 // Use this for initialization void Start () &#123; value = 100f; blood = new Rect(250, 100, 150, 20); &#125; // Update is called once per frame void OnGUI() &#123; if (GUI.Button(new Rect(20, 20, 80, 40), &quot;Attack&quot;)) &#123; if (value &gt;= 10) &#123; value -= 10; &#125; else &#123; value = 0; &#125; &#125; if (GUI.Button(new Rect(20, 130, 80, 40), &quot;Revive&quot;)) &#123; value = 100; &#125; GUI.HorizontalScrollbar(blood, 0.0f, value, 0.0f, 100f); &#125;&#125; ​ 本次难点还是在于如何实现血条的效果，查阅资料之后，采用了 GUI.HorizontalScrollbar() ， 即滚动条，具体参数如下： public static float HorizontalScrollbar(Rect position, float value, float size, float leftValue, float rightValue); ​ 其中第一个参数是一个长方形，第二个参数官方的说明是： The position between min and max. ​ 我试了多次之后，发现这个是控制血条缩减的方向的，例如现在是0，就是从右往左缩减，如果是最大值100，则是从左往右缩减。若是一个中间值，则先从左往右，然后缩减到相应比例时，再从右往左缩减。 ​ 第三个是当前的血量，即一个区间内的值；第四和第五分别是区间的最小值和最大值。其实最后也可以加个 GUIStyle 的参数来着，我添加了之后不知怎么的总是显示不出来，然后还报了一堆警告，就没用了。 使用说明：预制已给出，为Prefabs/IMGUI，将其拖入场景中，点击运行即可。初始血量为100，点击Attack掉10点血，点击Revive复活，即血量全满。UGUI​ 与 IMGUI 类似的是，首先新建一个Cube(看心情，是个对象就行)，在Cube下新建子对象Canvas，之后再在Canvas下新建一个Slider，两个Button，控制攻击和复活，具体目录结构如下： ​ 其中，UGUI是Cube的名称，Slider目录下原本还有 Handle Slide Area ，此处不用，删去，否则会遮挡血条效果。 ​ 设置Slider的 Rect Transform 中的 Width 和 Height 分别为80和20，为血条的大小，然后设置 Scale 下的X和Y分别为0.02，0.01，控制血条在X和Y轴上的比例因子，可个性化设置。 ​ 其次设置血条颜色，Slider–&gt;Fill Area–&gt;Fill–&gt;Image–&gt;Color，挑选自己喜欢的颜色即可。 ​ 最后回到Slider的Inspector界面，如下设置： ​ 其中 Direction 是血条缩减方向， Min Value 是血量最小值， Max Value 是最大值， Value 是当前血量，通过拖动滑条可看到血量变化效果。此处需要说明的是，我刚开始设置的时候发现血量最多也到不了最右边，即看起来永远也不会满的样子，之后通过设置 Fill Area –&gt; Fill 中的Rect Transform属性解决，将其中所有数值设为0即可。其实也可以通过不断更改数值，发现各个属性的作用的，这个可以自己摸索，也是蛮有意思的。 ​ 接下来开始写代码，要求中有要血条时刻面对摄像机，所以代码如下，将其绑定到Canvas下即可： 12345678910111213141516using System.Collections;using System.Collections.Generic;using UnityEngine;public class Follow : MonoBehaviour &#123; // Use this for initialization void Start () &#123; &#125; // Update is called once per frame void Update () &#123; this.transform.rotation = Camera.main.transform.rotation; &#125;&#125; ​ 然后设置 Canvas–&gt;Render Mode–&gt;World Space ， 然后将主摄像机拖入下面的 Event Camera 。即是使UI采用世界模式。 ​ 由于采用世界模式，所以继续编写血条坐标变化的代码，将其绑定到Slider下即可： 123456789101112131415using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class UGUI : MonoBehaviour &#123; private RectTransform rectTransform; // Use this for initialization void Start () &#123; rectTransform = this.GetComponent&lt;RectTransform&gt;();; Camera.main.transform.position = new Vector3(0, 0, -5); Vector3 postion = Camera.main.ScreenToWorldPoint(this.transform.position); rectTransform.position = postion + new Vector3(0, 1, 5); &#125;&#125; ​ 之后继续设置两个Button，大小和位置通过调整，适应即可，颜色之类也可自定义，具体以攻击按钮为例： ​ 最后就是脚本的书写了，Button有个 On Click 属性，通过查询官方手册后得知了用法，如下： 12345678910111213141516171819202122232425using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class Attack : MonoBehaviour &#123; public Slider slider; // Use this for initialization void Start() &#123; Button btn = this.GetComponent&lt;Button&gt;(); btn.onClick.AddListener(Click); &#125; public void Click() &#123; if(slider.value &gt;= 10) &#123; slider.value -= 10; &#125; else &#123; slider.value = 0; &#125; &#125;&#125; 123456789101112131415161718using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class Revive : MonoBehaviour &#123; public Slider slider; // Use this for initialization void Start () &#123; Button btn = this.GetComponent&lt;Button&gt;(); btn.onClick.AddListener(Click); &#125; public void Click() &#123; slider.value = 100; &#125;&#125; ​ 将这两个脚本绑定到相应的Button上，此处的难点是刚开始时无法获得Slider的value，之后查找官方手册和资料，找到了这种解决方法，提供一个公有的接口，将其在外部设置为血条Slider属性即可，然后就解决了。 效果图： 使用说明：左边为攻击按钮，右边为复活按钮，操作规则与IMGUI相同。预制为Prefabs/UGUI，拖入场景之中即可使用。分析：IMGUI：制作步骤较为简单，但是也很简陋，效果明显不如UGUI(也有可能是我水平有限)。其次，血条位置不能够随着对象移动而变化，因为长方形的坐标是相对于屏幕的，所以不会变化。UGUI：效果明显要好很多，血条也可以随着物体移动。但是制作较为复杂，容易出错，需要仔细阅读官方文档。由于上课老师课件讲过UGUI血条在World Space下的弊端，就是血条会暴露对象的位置，我本来是打算采用ScreenSpace-Overlay模式的，然后最后没有做出来，只能先这样子，之后再钻研下吧，对UI还是了解不够。资源传送门：点这里 演示视频：看看吧","categories":[{"name":"3D Game","slug":"3D-Game","permalink":"http://dukecheung.github.io/categories/3D-Game/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://dukecheung.github.io/tags/博客/"}]},{"title":"Unity 3D 巡逻兵","slug":"Unity-3D-巡逻兵","date":"2018-05-11T12:00:00.000Z","updated":"2018-05-11T14:20:24.412Z","comments":true,"path":"2018/05/11/Unity-3D-巡逻兵/","link":"","permalink":"http://dukecheung.github.io/2018/05/11/Unity-3D-巡逻兵/","excerpt":"要求： 创建一个地图和若干巡逻兵(使用动画)； 每个巡逻兵走一个3~5个边的凸多边型，位置数据是相对地址。即每次确定下一个目标位置，用自己当前位置为原点计算；","text":"要求： 创建一个地图和若干巡逻兵(使用动画)； 每个巡逻兵走一个3~5个边的凸多边型，位置数据是相对地址。即每次确定下一个目标位置，用自己当前位置为原点计算； 巡逻兵碰撞到障碍物，则会自动选下一个点为目标； 巡逻兵在设定范围内感知到玩家，会自动追击玩家； 失去玩家目标后，继续巡逻； 计分：玩家每次甩掉一个巡逻兵计一分，与巡逻兵碰撞游戏结束； 说明： 新建一个空对象，将 FirstSceneController.cs , PatrolFactory.cs , UI.cs 挂载到该对象上即可运行。 使用WSAD或者方向键控制方向，WS控制前进后退，AD控制向左右转向。空格键加速。 若WSAD无法正常工作，切换键盘为大写英文或者使用方向键控制即可。 游戏里共有三类对象，分别为玩家，巡逻兵，和地板。玩家我是在Asset Store里找的资源，巡逻兵为老师给的Garen，地板即是简单Cube与Plane的组合，其实还贴了墙纸，只不过摄像机看不清纹路。 效果图： 实现： Action 接口，声明玩家的动作： 123456public interface Action&#123; void move(float x, float z);//移动玩家 void gameOver();//游戏结束 void changeScore();//加分&#125; ​ Director 导演类，使用单例模式实现： 12345678910111213141516171819202122232425262728293031323334public class Director : System.Object&#123; private static Director _instance; private bool isEnd = false;//标志游戏是否结束 public SceneController currentSceneController &#123; get; set; &#125; public static Director getInstance() &#123; if (_instance == null) &#123; _instance = new Director(); &#125; return _instance; &#125; public bool getState() &#123; return _instance.isEnd; &#125; public void end() &#123; _instance.isEnd = true; &#125; public void reset()//重新开始游戏 &#123; _instance.isEnd = false; &#125; public int getFPS() &#123; return Application.targetFrameRate; &#125; public void setFPS(int fps) &#123; Application.targetFrameRate = fps; &#125;&#125; ScoreRecorder 记分员，同样采用单例模式： 1234567891011121314151617181920212223242526public class ScoreRecorder:System.Object//记分员&#123; private int score = 0; private static ScoreRecorder instance; public static ScoreRecorder getInstance() &#123; if(instance == null) &#123; instance = new ScoreRecorder(); &#125; return instance; &#125; public void record()//加分 &#123; instance.score++; &#125; public int getScore() &#123; return instance.score; &#125; public void reset() &#123; instance.score = 0; &#125;&#125; PatrolFactory 工厂模式，由于此次不牵扯回收问题，所以只用写创造巡逻兵即可： 12345678910111213141516171819202122232425262728293031323334public class PatrolFactory : MonoBehaviour &#123; List&lt;GameObject&gt; list = new List&lt;GameObject&gt;(); public List&lt;GameObject&gt; getPatrolmans() &#123; int[] x = new int[2] &#123; -10, 5 &#125;; int[] z = new int[3] &#123; -5, 0, 5 &#125;; Vector3[] location = new Vector3[9]; int count = 0; for(int i = 0;i &lt; 2; i++) &#123; for(int j = 0;j &lt; 3; j++) &#123; GameObject patrolman = Instantiate(Resources.Load(&quot;Prefabs/Patrolman&quot;), new Vector3(0, 0, 7), Quaternion.identity) as GameObject; location[count] = new Vector3(x[i], 0, z[j]); patrolman.transform.position = location[count]; patrolman.GetComponent&lt;Animator&gt;().SetBool(&quot;run&quot;, true);//默认巡逻兵为移动 list.Add(patrolman); count++; &#125; &#125; return list; &#125; public void removeRigid()//结束后调用，移除刚体，以免对象之间继续碰撞 &#123; for(int i = 0;i &lt; list.Count; i++) &#123; list[i].GetComponent&lt;Animator&gt;().SetBool(&quot;run&quot;, false); list[i].GetComponent&lt;Animator&gt;().SetBool(&quot;idle&quot;, true); Destroy(list[i].GetComponent&lt;Rigidbody&gt;()); &#125; &#125;&#125; PatrolmanController 负责控制巡逻兵的逻辑部分，需将其绑定到巡逻兵预制上。 我认为本次作业的难点有一大半出在此处，关键在于如何实现碰撞和如何处理碰撞。 关于实现碰撞： 首先，给巡逻兵，墙体和玩家添加刚体，并且不使用重力，给墙体选中 is Kinematic 属性，使其不会移动。这是碰撞产生的先决条件。 其次，给巡逻兵，墙体和玩家添加碰撞器，设置好大小，尤其是玩家和巡逻兵，使用 Capsule Collider 直径以刚好包住对象为宜。 最后，给巡逻兵添加触发器，即添加 Box Collider ，半径可设置稍微大一点，选中 isTrigger ，这样就可以啦。 以下是关于碰撞及触发逻辑的处理，需要注意的是，若巡逻兵在追逐玩家的过程中，玩家跑到了墙后面，或者说玩家与巡逻兵之间仅一墙之隔，巡逻兵也需优先处理碰撞到墙的情况，即碰墙或巡逻兵的优先级高于碰玩家。 这样处理的好处是不会出现隔山打牛的情况，或者巡逻兵穿墙而入，并且代码量不多。 最后，当巡逻兵追逐玩家时，速度会加快，远离之后速度恢复正常。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697void OnCollisionEnter(Collision collision)//碰撞&#123; if(collision.gameObject.tag == &quot;patrolman&quot;) &#123; canFollow = false;//添加变量，当与其他巡逻兵或者墙体碰撞时，优先处理 direction = (direction + 1) % 4; setNewPath(); &#125; else if(collision.gameObject.tag == &quot;wall&quot;) &#123; canFollow = false; direction = (direction + 1) % 4; setNewPath(); &#125; if (collision.gameObject.tag == &quot;player&quot; &amp;&amp; !dir.getState()&amp;&amp;canFollow) &#123; if (hit != null) &#123; this.GetComponent&lt;Animator&gt;().SetBool(&quot;attack&quot;, true); dir.end(); hit(); &#125; &#125;&#125;void OnCollisionExit(Collision collision)//退出碰撞&#123; if(collision.gameObject.tag == &quot;patrolman&quot;|| collision.gameObject.tag == &quot;wall&quot;) &#123; canFollow = true; &#125;&#125;void OnTriggerEnter(Collider other)//进入触发器范围&#123; if(other.transform.tag == &quot;player&quot; &amp;&amp; !dir.getState() &amp;&amp; canFollow) &#123; target = other.transform.position; this.transform.LookAt(other.transform.position); speed *= 2; &#125;&#125;void OnTriggerExit(Collider other)//退出触发器范围&#123; if (other.transform.tag == &quot;player&quot; &amp;&amp; !dir.getState() &amp;&amp; canFollow) &#123; if (scoreRecord != null) &#123; scoreRecord(); &#125; setNewPath(); speed /= 2; &#125;&#125;void setNewPath()&#123; System.Random ran = new System.Random(); length = ran.Next(5, 6); x = this.transform.position.x; z = this.transform.position.z; if (direction == 0) &#123; x -= length; &#125; else if (direction == 1) &#123; z += length; &#125; else if (direction == 2) &#123; x += length; &#125; else if (direction == 3) &#123; z -= length; &#125; if(x &lt; -15)//若超出地图，则设置边缘 &#123; x = -14; &#125; if(x &gt; 15) &#123; x = 14; &#125; if(z &lt; -15) &#123; z = -14; &#125; if(z &gt; 15) &#123; z = 14; &#125; target = new Vector3(x, 0, z); this.transform.LookAt(target);&#125; FirstSceneController 场景控制器，继承 Action 和 SceneController 接口，实现相应函数。 本次游戏的另一个重点，订阅与发布模式也在此实现。 FirstSceneController 订阅了 PatrolmanController 发布的事件，并且做出相应的动作. 12345678910void Enable()//订阅事件&#123; PatrolmanController.hit += gameOver; PatrolmanController.scoreRecord += changeScore;&#125;void Disable()//取消订阅&#123; PatrolmanController.hit -= gameOver; PatrolmanController.scoreRecord -= changeScore;;&#125; 实现接口： 123456789101112131415161718192021222324252627282930313233343536public void LoadResources()&#123; director = Director.getInstance(); director.currentSceneController = this;&#125;public void move(float x, float z) &#123; if (!director.getState()) &#123; player.GetComponent&lt;Animator&gt;().SetBool(&quot;run&quot;, true); player.transform.Translate(0, 0, z * Time.deltaTime); player.transform.Rotate(0, x * rotate_speed * 3 * Time.deltaTime, 0); if (player.transform.position.y != 0)//确保y为0 &#123; player.transform.position = new Vector3(player.transform.position.x, 0, player.transform.position.z); &#125; if (player.transform.localEulerAngles.x != 0 || player.transform.localEulerAngles.z != 0)//确保只能左右旋转 &#123; player.transform.localEulerAngles = new Vector3(0, player.transform.localEulerAngles.y, 0); &#125; &#125;&#125;public void gameOver() &#123; director.end(); player.GetComponent&lt;Animator&gt;().SetBool(&quot;run&quot;, false); player.GetComponent&lt;Animator&gt;().SetBool(&quot;idle&quot;, true); Destroy(player.GetComponent&lt;Rigidbody&gt;()); factory.removeRigid(); Disable();&#125;public void changeScore()&#123; score.record();&#125; UI 实现了基本的计时器，计分和重新开始选项。 由于巡逻兵追逐速度加快，并且触发器的范围并不是很大，所以容易造成玩家基本不可能逃出巡逻兵的魔爪。所以我设置了按下 Space 键加速的功能，方便逃出追捕范围，容易得分，可以多次在死亡的边缘试探。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void Update()&#123; action = Director.getInstance().currentSceneController as Action; float offsetX = Input.GetAxis(&quot;Horizontal&quot;); float offsetZ = Input.GetAxis(&quot;Vertical&quot;); action.move(offsetX * rate, offsetZ * rate); if (Input.GetKeyDown(KeyCode.Space)) &#123; rate *= 3; &#125; if (Input.GetKeyUp(KeyCode.Space)) &#123; rate = 3; &#125; if (flag == 1) &#123; timer += Time.deltaTime; if (timer &gt;= 1f) &#123; second++; timer = 0; &#125; if (second &gt;= 60) &#123; minute++; second = 0; &#125; if (minute &gt;= 60) &#123; minute = 0; &#125; &#125;&#125;void OnGUI()&#123; str = string.Format(&quot;&#123;0:00&#125;:&#123;1:00&#125;&quot;, minute, second);//计时器 str = &quot;Time: &quot; + str; GUIStyle style = new GUIStyle(); style.fontSize = 20; GUI.Label(new Rect(520, 0, 100, 200), str, style); int score = s.getScore();//记分 string ss = &quot;Score: &quot; + score.ToString(); GUI.Label(new Rect(0, 0, 100, 200), ss, style); if (director.getState() == true) &#123; flag = 0; if (GUI.Button(new Rect(280, 130, 100, 50), &quot;RESET&quot;)) &#123; flag = 1; timer = 0; minute = 0; second = 0; director.reset(); s.reset(); SceneManager.LoadScene(&quot;Scene&quot;); &#125; &#125; &#125; 总结：本次作业还是有些难的，不过收获也颇多，除了订阅与发布模式，动画系统、碰撞器、触发器等部件的特性也有了很多了解。上课跟着老师做，跟自己独立完成还是有很大区别的，还是要勤动手啊。 就是过程有点痛苦。 查看代码点这里 ，附上演示视频。","categories":[{"name":"3D Game","slug":"3D-Game","permalink":"http://dukecheung.github.io/categories/3D-Game/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://dukecheung.github.io/tags/博客/"}]},{"title":"Unity 3D 鼠标打飞碟之改进版","slug":"Unity-3D-鼠标打飞碟之改进版","date":"2018-04-24T12:17:00.000Z","updated":"2018-04-24T13:59:17.658Z","comments":true,"path":"2018/04/24/Unity-3D-鼠标打飞碟之改进版/","link":"","permalink":"http://dukecheung.github.io/2018/04/24/Unity-3D-鼠标打飞碟之改进版/","excerpt":"效果图：","text":"效果图： 场景也可加天空盒等组件进行优化，选择很多。 要求： 按 adapter模式 设计图修改飞碟游戏 使它同时支持物理运动与运动学（变换）运动 思路： &emsp; 新建一个 IActionManager 类来管理动作，CCActionManager 和 PhysisActionManager 负责具体的运动学和物理引擎实现动作。其余 DiskFactory , DiskData 稍作修改即可。 实现： Action 接口，声明基类的动作： 123456public interface IAction&#123; void play(); void randomAction(int num, int level); void remove(DiskData disk);&#125; IActionManager 基类，实现接口动作，有两个类的对象和一个模式选择变量，当用户选择不同的模式时，实现不同的动作，以 play() 为例： 123456789101112131415161718192021222324CCActionManager cc;PhysisActionManager ph;int mode;public IActionManager()&#123; cc = new CCActionManager(); ph = new PhysisActionManager(); mode = 0;&#125;public void setMode(int i)&#123; mode = i;&#125;public void play()&#123; if (mode == 0) &#123; cc.play(); &#125; else &#123; ph.play(); &#125;&#125; CCAction 运动学类，通过坐标变化来实现运动，包含一个单例类的 DiskFactory ，用来回收和生产飞碟： 12345678910List&lt;DiskData&gt; diskList;DiskFactory diskFactory;float gravity = 9.8f;Color color;public CCActionManager()&#123; diskList = new List&lt;DiskData&gt;(); diskFactory = DiskFactory.getInstance();&#125; 其次，在 randomAction() 类中，通过不同的 level 来区分不同的难度，主要体现在速度不同： 12345678910111213141516public void randomAction(int ufoNum, int level)&#123; setColor(level); for (int i = 0; i &lt; ufoNum; i++) &#123; Vector3 position = new Vector3(0, 0, 0);//飞碟的起始位置 float speed = level * 10f;//飞碟速度 Vector3 direction = new Vector3( UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(40f, 80f), UnityEngine.Random.Range(50f, 100f));//飞碟方向 direction.Normalize();//单位化该方向向量，以免产生较大误差 Ruler ruler = new Ruler(color, position, speed, direction);//新建一个规则 diskList.Add(diskFactory.getDisk(ruler));//添加飞碟 &#125;&#125; 再者，在 FirstSceneCtroller 类中每一帧会调用 play() 函数，以此实现飞碟的运动和回收： 1234567891011121314public void play()&#123; for (int i = 0; i &lt; diskList.Count; i++) &#123; move(diskList[i]);//移动飞碟 &#125; for (int i = 0; i &lt; diskList.Count; i++) &#123; if (diskList[i].gameObject.transform.position.y &lt; 0)//若飞碟低于地面，则回收 &#123; remove(diskList[i]); &#125; &#125;&#125; PhysisActionManager 此类负责实现物理引擎实现UFO运动，基本思路与运动学较为相似，区别是需要给UFO加一个外力，让其自己运动而不是人为的坐标变换。 我选择的方法是给UFO添加 ConstantForce 组件，一个恒力，以此实现运动效果，当物体被回收时，去掉这个恒力，具体实现代码在 DiskData 类中，如下： 123456789public void setForce(Vector3 f)&#123; this.gameObject.AddComponent&lt;ConstantForce&gt;().force = f;&#125;public void removeForce()&#123; Destroy(this.gameObject.GetComponent&lt;ConstantForce&gt;()); Destroy(this.gameObject.GetComponent&lt;Rigidbody&gt;());&#125; randomAction() 如下： 123456789101112131415public void randomAction(int ufoNum, int level)&#123; setColor(level); for (int i = 0; i &lt; ufoNum; i++) &#123; Vector3 position = new Vector3(0, 0, -20f); float speed = level * 10f;//飞碟速度 Vector3 force = new Vector3( UnityEngine.Random.Range(-5f, 5f), UnityEngine.Random.Range(10f, 12f), speed); Ruler ruler = new Ruler(color, position, 0, Vector3.zero);//新建一个规则 diskList.Add(diskFactory.getDisk(force,ruler));//添加飞碟 &#125;&#125; 此外，在 play() 函数中，就不需设置 move 函数了，只需回收飞碟即可。 FirstSceneCtroller 场景控制器，负责整个场景的调度，其中加入 IActionManager 的对象，实现物体运动： 12345678910111213141516171819Director director;IActionManager ac;ScoreRecorder score;float interval = 0;//发射飞镖的间隔时间int level = 0;//难度级别public int ufoNum = 1;//每一次发射飞碟的数目void Awake()&#123; director = Director.getInstance();//单例类 director.currentSceneCtroller = this; score = ScoreRecorder.getInstance(); LoadResource();&#125;public void LoadResource()&#123; ac = new IActionManager();&#125; 注意这里除了导演类的实例外，还有个记分员的实例，其实现与导演类相似，负责场景中的计分，实现十分简单，详见代码，在此不多加赘述。 在场景中，每一帧都会调用一次物体的运动函数，实现刷新效果： 1234567891011121314151617181920212223void Update()&#123; interval += Time.deltaTime; if (interval &gt;= 1f &amp;&amp; director.state == State.PLAYING &amp;&amp; level &gt; 0)//若间隔大于1s且处于play且已设置好level &#123; ac.randomAction(ufoNum, level); interval = 0;//间隔重新置为0 &#125; ac.play(); if (Input.GetButtonDown(&quot;Fire1&quot;))//开火 &#123; Vector3 mousePosition = Input.mousePosition; Camera cam = Camera.main; Ray ray = cam.ScreenPointToRay(mousePosition); RaycastHit hit; if (Physics.Raycast(ray, out hit)) &#123; score.record(level);//计分 recycle(hit.transform.gameObject.GetComponent&lt;DiskData&gt;());//回收 &#125; &#125;&#125; DiskFactory 该类负责UFO的制作与回收，即工厂类，主要有两个list，分别存已用过的飞碟和回收的： 1234public DiskData diskPrefab;//飞碟预制public static DiskFactory _instance;List&lt;DiskData&gt; used;//已用过的List&lt;DiskData&gt; free;//未用 负责生产飞碟的函数共有两个版本，分别是对于 CCActionManager 和 PhysisActionManager 类的，差别不大，主要区别在是否添加恒力，以下以运动学的为例： 12345678910111213141516public DiskData getDisk(Ruler ruler)//根据参数设置飞碟&#123; DiskData disk; if (_instance.free.Count &gt; 0)//若不空，则从中找 &#123; disk = _instance.free[0]; _instance.free.RemoveAt(0); &#125; else &#123; disk = Instantiate(diskPrefab); &#125; disk.ruler = ruler; _instance.used.Add(disk); return disk;&#125; 回收飞碟类： 12345678public void freeDisk(DiskData disk)//回收飞碟&#123; _instance.free.Add(disk); if (!_instance.used.Remove(disk))//抛出错误 &#123; throw new System.Exception(); &#125;&#125; DiskData 飞碟类，包含一个 Ruler 类，包含飞碟的种种规则，也可不封装成类，皆可。 123456789101112131415161718192021222324252627Ruler _ruler;public float x = 0, y = 0, z = 0;//用于存储该飞碟在飞行方向上的速度public Ruler ruler&#123; get &#123; return _ruler; &#125; set &#123; _ruler = value; x = value.speed * value.direction.x; y = value.speed * value.direction.y; z = value.speed * value.direction.z; gameObject.GetComponent&lt;Renderer&gt;().material.color = value.color; gameObject.transform.position = value.position; &#125;&#125;public void setForce(Vector3 f)&#123; this.gameObject.AddComponent&lt;ConstantForce&gt;().force = f;&#125;public void removeForce()&#123; Destroy(this.gameObject.GetComponent&lt;ConstantForce&gt;()); Destroy(this.gameObject.GetComponent&lt;Rigidbody&gt;());&#125; 需要注意的是，在使用该类时，需将其绑定到制作好的预制上，然后删除对象，即可正常使用。此时，代码中的 gameObject 就指的是脚本文件绑定的对象，即预制。 将 UI.cs ， DiskFactory.cs ， FirstSceneController.cs 拖到空对象上，拖入预制，即可运行，可自主设置每次出现的飞碟数。 还有 BaseCode.cs ， UI.cs 等文件就不加赘述了，详情可见Github 源码 。 如果有任何不懂的话，可参考第一版 鼠标打飞碟 和 演示视频 。","categories":[{"name":"3D Game","slug":"3D-Game","permalink":"http://dukecheung.github.io/categories/3D-Game/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://dukecheung.github.io/tags/博客/"}]},{"title":"MIPS汇编语言实现冒泡排序","slug":"2018-01-11","date":"2018-04-11T04:38:00.000Z","updated":"2018-11-01T15:50:24.671Z","comments":true,"path":"2018/04/11/2018-01-11/","link":"","permalink":"http://dukecheung.github.io/2018/04/11/2018-01-11/","excerpt":"题目要求：键盘输入10个无序无符号整数，实现降序输出。","text":"题目要求：键盘输入10个无序无符号整数，实现降序输出。 思路： &emsp; &emsp; 首先，写出对应的C++代码，实现排序功能，为方便MIPS指令运行，我将冒泡排序做了一点改进：每次二重循环下标都从0开始，这样就无需记录当前数组移动的下标位置，方便许多。 &emsp; &emsp; 其次，MIPS设计的重点我认为在循环的跳转上，如何递增变量，如何跳转到相应的循环需要仔细设计。我将数组的重置，j = 0放在第一重循环中，然后进行判断i&lt;10，若真，则进入第二重循环，二重循环中检测到j == 9时进入相应的模块将i++，再跳转到第一重循环中，如此即可实现排序所需的两重循环的切换。 &emsp; &emsp; 最后输出前需将对应的计数器i归零，循环输出结果和间隔符，就可以得到结果。 程序流程图： 运行结果： MIPS：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778.data.align 2 array: .space 40 # 10 integers seperate: .asciiz &quot; &quot; inputMessage: .asciiz &quot;Please enter 10 numbers:\\n&quot;.text.globl mainmain: la $a0, inputMessage li $v0, 4 syscall la $t0, array addi $t1, $zero, 0 # i addi $t2, $zero, 0 # j add $t5, $t0, $zero # head of pointers addi $t6, $zero, 10 # constant addi $t7, $zero, 9addi $t1, $zero, 0inputNumber: li $v0, 5 syscall sw $v0, 0($t0) addi $t0, $t0, 4 # array++ addi $t1, $t1, 1 # i++ blt $t1, $t6, inputNumber # i&lt;10 addi $t1, $zero, 0 # i = 0firstLoop: la $t5, array # t5 = array[0] addi $t2, $zero, 0 # j = 0 blt $t1, $t6, secondLoop # i &lt; 10, secondLoop beq $t1, $t6, init # i == 10, init secondLoop: beq $t2, $t7, nextLoop # j == 9, nextLoop lw $t3, 0($t5) lw $t4, 4($t5) blt $t3, $t4, swap addi $t5, $t5, 4 addi $t2, $t2, 1 # j++ j secondLoopnextLoop: addi $t1, $t1, 1 # i++ j firstLoopswap: sw $t3, 4($t5) sw $t4, 0($t5) addi $t5, $t5, 4 addi $t2, $t2, 1 # j++ j secondLoopinit: la $t0, array # t0 = array[0] addi $t1, $zero, 0 # i = 0printResult: lw $a0, 0($t0) li $v0, 1 syscall la $a0, seperate li $v0, 4 syscall addi $t0, $t0, 4 addi $t1, $t1, 1 blt $t1, $t6, printResultli $v0, 10syscall C++：123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;int main()&#123; int arr[10] = &#123;0&#125;; int i = 0, j = 0, k = 0, temp = 0; for(i = 0;i &lt; 10;i++)&#123; cin &gt;&gt; arr[i]; &#125; for(i = 0;i &lt; 10;i++)&#123; for(j = 0;j &lt; 9;j++)&#123; if(arr[j] &lt; arr[j+1])&#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; for(int t = 0;t &lt; 10;t++)&#123; cout &lt;&lt; arr[t] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; 补充说明：若要实现自己定义输入的数字数，则只需在 .main 下添加一句： 123li $v0, 5syscallsw $v0, 0($t6) 同时， t7 的值也要改为： 1addi $t7 $t6 -1 array 的size也要足够大。 同理，若要实现 升序 ，只需将 secondLoop 中的第四句改为： 1blt $t4 $t3 swap 即可实现效果啦。","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://dukecheung.github.io/categories/汇编语言/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://dukecheung.github.io/tags/博客/"}]},{"title":"Unity 3D 牧师与魔鬼场景改进版","slug":"Unity 3D牧师与魔鬼场景改进版","date":"2018-04-10T14:17:00.000Z","updated":"2018-11-01T15:31:18.266Z","comments":true,"path":"2018/04/10/Unity 3D牧师与魔鬼场景改进版/","link":"","permalink":"http://dukecheung.github.io/2018/04/10/Unity 3D牧师与魔鬼场景改进版/","excerpt":"场景改进效果图：","text":"场景改进效果图： Skybox ： 天空盒，即天空场景，添加后可看到不同的天空场景。 首先，在Unity的 Assets Store 中搜索 Skybox ，下载资源，主要为六张图片。之后新建Material，Inspector—-&gt;Shader—-&gt;Skybox，拖入六张图片，即制作好了一个材料。 下一步为摄像机添加组件，Add Component—-&gt;Rendering—-&gt;Skybox，拖入上一部创建好的图片就OK啦。 摄像机 ： 打开Camera的Inspector视图，可看到Projection属性： 有两个选项：Perspective(透视视图) ，和 Orthographic(正交视图) 。正交视图与摄像机距离无关，实现2D投影效果，透视试图则是属于3D效果。 设置两个摄像机，一个为主，采用透视视图，另一为辅，为正交视图。 需注意的重点是，若要使辅助摄像机位于视图左下角，则需调整 Depth 和视图大小，确保辅助摄像机的深度大于主摄像机。 _地形_ ： Create—-&gt;3D Object—-&gt;Terrain，即可创建地形对象： 可用来改造地形，种树，花草等等，不过若要种树，则需从 Assets Store 中下载相关资源，从中找到树木的预制，即可应用于地形中。 _海水_ ： Assets—-&gt;Import Package—-&gt;Environment，即可从该资源包中找到 Water 预制，拖入场景中，调整位置即可实现海水效果。 牧师与魔鬼详见代码","categories":[{"name":"3D Game","slug":"3D-Game","permalink":"http://dukecheung.github.io/categories/3D-Game/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://dukecheung.github.io/tags/博客/"}]},{"title":"Unity 3D 基础概念","slug":"Unity 3D之Homework1","date":"2018-03-27T11:54:00.000Z","updated":"2018-04-11T03:59:00.127Z","comments":true,"path":"2018/03/27/Unity 3D之Homework1/","link":"","permalink":"http://dukecheung.github.io/2018/03/27/Unity 3D之Homework1/","excerpt":"基础概念 GameObjects: 游戏对象，即游戏中的最基本单位，游戏中的每一个对象都是游戏对象。它相当于一个容器，本身并无太多属性，需添加各种组件，资源后才能达到设计者的所希望的游戏行为目的。","text":"基础概念 GameObjects: 游戏对象，即游戏中的最基本单位，游戏中的每一个对象都是游戏对象。它相当于一个容器，本身并无太多属性，需添加各种组件，资源后才能达到设计者的所希望的游戏行为目的。 Assets: 指可应用于Unity上的各种资源，为游戏添加各种属性，从而实现目标效果；同时，一个Unity Project的Assets文件夹指存储于本地计算机中的各种图片，预制，script等文件的总和。一个Assets中可以包含多个GameObject，GameObject从逻辑上讲存储于Assets文件夹中。 游戏结构目录：Assets Scene 保存游戏场景 Game 保存美术资源 Materials 保存材质球，用于调整颜色等 Prefabs 保存预制，即游戏对象的模板，方便克隆 Model _模型_ Animations 保存动画文件 Audio 音频文件 Textures 贴图文件 UI UI文件 Scripts 脚本文件 Plugins _插件_ Editor 保存编辑器类文件 MonoBehaviour 基本行为触发条件：代码如下： 1234567891011121314151617181920212223242526272829303132// Use this for initializationvoid Start () &#123; Debug.Log(&quot;init Start&quot;);&#125;// Update is called once per framevoid Update () &#123; Debug.Log(&quot;init Update&quot;);&#125;void Awake()&#123; Debug.Log(&quot;init Awake&quot;);&#125;void FixedUpdate()&#123; Debug.Log(&quot;init FixedUpdate&quot;);&#125;void LateUpdate()&#123; Debug.Log(&quot;init LateUpdate&quot;);&#125;void OnGUI()&#123; Debug.Log(&quot;init OnGUI&quot;);&#125;void OnDisable()&#123; Debug.Log(&quot;init OnDisable&quot;);&#125;void OnEnable()&#123; Debug.Log(&quot;init OnEnable&quot;);&#125; Start: Per frame: End: 结论: Awake(): 当脚本实例被载入时调用； Start(): 在Update()前被调用一次； Update(): 行为启用时，每一帧被调用一次； FixedUpdate(): 行为启用时，每一时间片被调用； LateUpdate(): 行为启用时，Update()之后被调用； OnGUI(): 每帧调用多次，响应GUI事件； OnEnable(): 当对象变为启用并激活时，调用该函数； OnDisable(): 当对象变为禁用或不活动时，调用该函数。 简单介绍GameObject, Transform 和 Component，并画出三者的UML图。 GameObject: Unity 场景中所有实体的基类。 Transform: 一个对象的位置，旋转和大小。 Component: 所有附加到游戏对象的属性的基类。 UML 简单代码 查找对象新建项目，其中有 Sphere 游戏对象，代码如下： 1234567891011121314151617void Start() &#123; Debug.Log(&quot;init start&quot;); &#125; void FixedUpdate() &#123; var x = GameObject.Find(&quot;Sphere&quot;); if (x.name != null) &#123; Debug.Log(&quot;find the gameobject&quot;); &#125; else &#123; Debug.Log(&quot;Not found&quot;); &#125; &#125; 添加子对象代码如下： 1234567void Start()&#123; GameObject sph = GameObject.Find(&quot;Sphere&quot;); GameObject child = GameObject.CreatePrimitive(PrimitiveType.Cube); child.transform.parent = sph.transform; Debug.Log(&quot;Success&quot;);&#125; 遍历对象树代码如下： 123456789GameObject obj = GameObject.Find(&quot;Sphere&quot;);print(&quot;父对象名称为:&quot; + obj.name + &quot; 有&quot; + obj.transform.childCount + &quot;个子对象&quot;);int i = 0;while (i &lt; obj.transform.childCount)&#123; Transform child = obj.transform.GetChild(i); print(&quot;这是第: &quot; + i + &quot; 个子对象, 名称为: &quot; + child.name); i++;&#125; 清除所有子对象代码如下： 1234567891011GameObject obj = GameObject.Find(&quot;Sphere&quot;);print(&quot;父对象名称为:&quot; + obj.name + &quot; 有&quot; + obj.transform.childCount + &quot;个子对象&quot;);int i = 0;while (i &lt; obj.transform.childCount)&#123; Transform child = obj.transform.GetChild(i); print(&quot;这是第: &quot; + i+1 + &quot; 个子对象, 名称为: &quot; + child.name); GameObject pchild = GameObject.Find(child.name); GameObject.Destroy(pchild); i++;&#125; 预设与对象克隆 Prefabs: 预制可以存储一个带有组件和属性的 GameObject 作为模板，当想创建新的实例时，可以直接拖动模板进行创建。对预制做的修改可以应用到由该模板生成的所有实例中，也可以单独编辑每一个实例。 总的来说，预设和对象克隆都能生成新的对象实例，但相比较而言，由 clone 生成的实例，编辑原对象时，就不能应用到所有实例中。 预制 table : 12345public GameObject prefab;void Start()&#123; Instantiate(prefab, new Vector3(2.0F, 0, 0), Quaternion.identity);&#125; 组合模式 组合模式: 定义：组合模式，将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对组合对象和单个对象的使用具有一致性。 包含三个部分：抽象构件，叶子构件和容器构件。 目的即是使得对根节点的调用方法对叶子节点同样适用，使得工作效率更高。 代码：​ 有三种发送消息的函数，其中BroadcastMessage()由父类发送给子类，括号里面：第一个参数为回应的函数，第二个参数为传递给回应函数的参数。 1234567void Start () &#123; gameObject.BroadcastMessage(&quot;MySon&quot;,&quot;I am your father&quot;);&#125;void MySon(string ss)&#123; Debug.Log(&quot;I am your son&quot;);&#125;","categories":[{"name":"3D Game","slug":"3D-Game","permalink":"http://dukecheung.github.io/categories/3D-Game/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://dukecheung.github.io/tags/博客/"}]}]}